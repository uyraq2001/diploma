\documentclass[bachelor, och, coursework, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}
\usepackage{tempora}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{minted}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}% <-- moves axis labels near ticklabels (respects tick label widths)
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\setcounter{tocdepth}{4} 
\setcounter{secnumdepth}{4}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\No}{\textnumero}
\newtheorem{lem}{Лемма}
\setminted{style=bw,
	linenos=true,
	breaklines=true,
	numbersep=5pt,
	tabsize=2,
	fontsize=\small,
	bgcolor=white}
\setmintedinline{style=bw,
	bgcolor=white,
	fontsize=\normalsize
	}	
\pgfplotsset{every axis legend/.append style={at={(0.6,1)},anchor=south west}}
%\pgfplotsset{every axis title/.style={at={(0.5,1)},above,yshift=6pt}}
\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{исследование индекса дружбы модели Барабаши"--~Альберт}

% Курс
\course{3}

% Группа
\group{311}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Козырева Юрия Дмитриевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{зав. каф., к.\,ф.-м.\,н., доцент} %должность, степень, звание
\saname{С.\,В.\,Миронов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
%\patitle{доцент, к.\,ф.-м.\,н.} 
%\paname{С.\,В.\,Миронов}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{1}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{16}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%\practStart{01.09.2019}
%\practFinish{31.12.2019}

% Год выполнения отчета
\date{2022}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr

% Раздел "Введение"
\intro
Наука о графах "---одно из приложений к весьма красивой и интересной науке "---науке о случайных графах. 

В повседневной жизни для решения многих задач часто используются случайные графы. Случайные графы нашли практическое применение во всех областях, где нужно смоделировать сложные сети "--- известно большое число случайных моделей графов, отражающих разнообразные типы сложных сетей в различных областях. Случайные графы применяются при моделировании и анализе биологических и социальных систем, сетей, а также при решении многих задач класса NP.

Случайные графы впервые определены венгерскими математиками Эрдёшем и Реньи в книге 1959 года <<On Random Graphs>>\cite{RG}  и независимо Гильбертом в его статье <<Random graphs>>\cite{RG1}.

Случайный граф "---общий термин для обозначения вероятностного распределения графов \cite{wico}. Их можно описать просто распределением вероятности или случайным процессом, создающим эти графы. 

Теория сучайных графов находится на стыке комбинаторики, теории графов и теории вероятностей. В основе ее лежит глубокая идея о том, что мощные инструменты современной теории вероятностей должны поспособствовать более верному осознанию природы графа, призваны помочь решению многих комбинаторных и теоретико-графовых задач \cite{habr}.

С математической точки зрения случайные графы необходимы для ответа на вопрос о свойствах типичных графов.

Модель Барабаши"--~Альберт является одной из наиболее популярных и хорошо изученных моделей случайных графов.

Индекс дружбы - один из показателей используемых в социологии при анализе социальных сетей и других социальных явлений, который определяется как отношение средней степени соседей к степени самого объекта. 

Целью настоящей работы является анализ индекса дружбы модели случайного графа Барабаши"--~Альберт. Для достижения этой цели необходимо решить следующие задачи.
\begin{itemize}
\item рассмотреть алгоритм Барабаши"--~Альберт для построения случайного графа;
\item реализовать алгоритм Барабаши"--~Альберт на некотором языке программирования;
\item реализовать параллельное вычисление индекса дружбы для построенного графа;
\item провести анализ закона распределения индекса дружбы графа, построенного по алгоритму Барабаши"--~Альберт.
\end{itemize}




\section{Теоретические сведения}

\subsection{Модели построения случайного графа}
Существуют различные модели построения случайных графов.
\subsubsection{Модель Эрдеша"--~Ренье}
Модель Ердеша"--~Ренье является одной из первых моделей случайного графа. Граф построенный по этой модели представляет собой совокупность множества вершин $ V=\{1,...,n\} $ и множества рёбер $ E $, состоящего из рёбер полного графа $ K_{n} $ построенного на множестве $ V $, выбранных по схеме Бернулли. Таким образом образуется случайный граф $ G=(V, E) $. Формально выражаясь, мы имеем вероятностное пространство
\[
G(n, p)=(\Omega_n, F_n, P_{n, p}),
\] 
в котором: $n$ "---количество вершин, $p$ "---вероятность появления новго ребра, $F_n$ "---сигма-множество,$ |\Omega_n\ |=2^N$ "---множество возможных рёбер,  $P_{n,p}\ (G)=p^{|E|} q^{\binom{n}{2}}-|E|\ $ "---вероятностная мера.
Таким образом, в модели Эрдеша"--~Реньи каждое ребро независимо от других ребер входит в случайный граф с вероятностью $p$. Модель Эрдеша"--~Реньи на данный момент является самой изученной моделью случайных графов\cite{rey2}.
\subsubsection{Модель Барабаши"--~Альберт}
Модель Барабаши"--~Альберт является одной из первых моделей веб"=гра\-фов. Веб-граф представляет собой ориентированный мульти-граф, вершинами в котором являются какие-либо конкретные структурные единицы в Интернете: речь может идти о страницах, сайтах, хостах, владельцах и пр. Для определенности будем считать, что вершинами веб-графа служат именно сайты. А рёбрами соединяются вершины, между которыми имеются ссылки.

Также Барабаши и Альберт была предложена модель предпочтительного присоединения\cite{BA}, основная идея которой заключается в том, что при присоединении к графу новой вершины проводится некоторое количество рёбер от добавленной вершины к уже существующим, при этом вероятность появления ребра межу новой вершиной и какой-то конкретной вершиной пропорциональна степени данной вершины(степенью вершины $v_i \in V$ графа $G = (V, E)$ называется колличество вершин, напрямую связанных с данной, т.е. \[deg(v_i) = |\{v \in V: (v, v_i) \in E \}|\] ). Однако в своих работах Барабаши и Альберт никак не конкретизировали, какую именно из этих моделей они предлагают рассматривать. 
\subsubsection{Модель Боллобаша"--~Риодана}
Одной из наиболее удачных и часто используемых моделей предпочтительного присоединения является модель Боллобаша"--~Риодана. Существуют две основных и, по сути, совпадающих модификации этой модели. В одной дается динамическое, а в другой статическое описание случайности\cite{rey1}.
\paragraph{Динамическая модификация}
В данной модификации при добавлении n-ной вершины проводятся $ n $ новых рёбер, при этом рёбра могут быть кратными, а также петлями и даже кратными рёбрами, при создании графа с единственной вершиной проводится петля в этой точке\cite{rey2}. Таким образом вероятность появления ребра $ (n,\ i),\ \ i\in[0,\ n-1] $ равна $ \frac{\deg\ i}{2n-1} $, где $ deg i $ "---количество уже проведенных рёбер из вершины $n$ в вершину $i$. Очевидно, что распределение вероятностей задано корректно, поскольку 
\[
 \sum_{i=1}^{n-1}\frac{deg\ i}{2n-1}+\frac{1}{2n-1}=\frac{2n-2}{2n-1}+\frac{1}{2n-1}=1, 
\]
где $deg i$ - степень (колличество соседей) i-той вершины.
\paragraph{Статическая модификация, или LCD-модель}
Данная модель основывается на объекте называемом линейной хордовой диаграммой (LCD). Для построения данного объекта требуется зафиксировать на оси абсцисс $ 2n $ точек $ {1,…,2n} $, разбить их на пары и соединить элементы каждой пары дугой, лежащей в верхней полуплоскости. Количество различных диаграмм равно
\[
l_n=\frac{(2n)!}{2^nn!}. 
\]
По каждой диаграмме строится граф с $ n $ вершинами и $ n $ ребрами по следующему алгоритму: 
\begin{itemize}
\item Идти слева направо по оси абсцисс пока не встретится правый конец какой-либо дуги, пусть позиция этой точки равна $ i_k $
\item Последовательность $ i_{k-1}+1$, $i_k $ объявляется списком смежности для $k$-той вершины, $ i_0=0 $
\item Если $ k<n $, $ k $ увеличивается на 1, переход на шаг (1).
\end{itemize}
	
При построении модели LCD случайно выбирается одна из возможных LCD и вероятность каждой диаграммы равной $ \frac{1}{l_n} $, где $ l_n $ – общее число диаграмм. Графы построенные по такой модели имеют те же свойства, что и графы построенные по динамической модификации схемы Боллобаша"--~Риодана.
Модель Чунг-Лу
Пусть нам задано некоторое конечное множество вершин $ V ={v_1 ,… , v_n}  $ и степень каждой вершины $ d_i$, $i=\overline{1,n} $. Генерация графа $ G = (V, E) $ происходит следующим образом:
\begin{itemize}
\item Формируем множество $ L $, состоящее из $ i \cdot d $ копий $ i \cdot v $ для каждого $ i $ от $ 1 $ до $ n $.
\item Задаем случайные паросочетания на множестве $ L $.
\item Для вершин $ u $ и $ v $ из $ Vs $ количество ребер в графе $ G $ , соединяющее их, равно числу паросочетаний между копиями $ u $ и $ v $ в $ L $\cite{article}.
\end{itemize}
Сгенерированный таким образом граф соответствует степенной модели $ P(a,b) $, описывающей графы, для которых:
\[
|\{v|\deg v=\ x\}|=\frac{e^\alpha}{e^\beta}. 
\]
\subsection{Индекс дружбы}

С момента появления социальных сетей  — Facebook, Vkontakte, LiveJournal, Instagram, LinkedIn, MySpace и т. д. прошло не так много времени, но они уже плотно вошли в повседневную жизнь многих людей.

Опросы показывают, что 76\% пользователей Интернета в России (по данным агентства PRT на январь 2014) и примерно 73\% жителей Соединенных Штатов являются активными пользователями социальных сетей, и эта цифра растет.\cite{psych}

В современном обществе социальные сети становятся огромной базой информации, которую ученые и работодатели все чаще привлекают для решения конкретных задач, будь то научное исследование или оценка кандидата на определенную должность.

Научный интерес к изучению пользователей социальных сетей стремительно растет. На данный момент накоплено большое количество эмпирического материала в отношении характеристик пользователей социальных сетей, который требует систематизации и осмысления.

В социальных сетях часто можно встретить явление именуемое парадоксом дружбы - в среднем соседи некоторого объекта имеют больше соседей, чем сам объект. Оно было обнаружено в 1991 году социологом из государственного университета Нью-Йорка Скоттом Фельдом (англ. Scott L Feld), в процессе изучения социальных сетей\cite{aw}.

Для наблюдения парадокса дружбы обычно используются несколько метрик. В момент времени $t$ для вершины $v_i$ в графе $G(t) = (V(t), E(t)$ сумма степеней всех соседей $v_i$ равна:
\[
s_i(t) = \sum_{j: (v_i, v_j ) \in E(t)} deg_j(t),
\]
средняя степень соседних вершин $\alpha_i(t)$:
\[
\alpha_i(t) = \dfrac{s_i(t)}{deg_i(t)}, 
\]
а индекс дружбы $\beta_i(t)$ определяется как отношение средней степени соседей $v_i$ к степени самой $v_i$: 
\[
\beta_i(t) = \dfrac{\alpha_i(t)}{deg_i(t)} = \dfrac{s_i(t)}{deg_i^2 (t)} = \dfrac{\sum_{j: (v_i, v_j ) \in E(t)} deg_j(t)}{deg_i^2 (t)},
\]
таким образом, если средняя степень соседей больше степени $v_i$ и парадокс дружбы выполняется, то $\beta_i(t) > 1$ \cite{fi}.

Например, социальные сети Facebook и Github подтверждают парадокс дружбы, что показано на рис. \ref{fig:img3} \cite{mir}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{examples1.jpg}
    \caption{Распределения индекса дружбы в\\ сети телефонных звонков и сети доставки Amazon}\label{fig:img3}
\end{figure}

\section{Реализация модели Барабаши"--~Альберт}
В ходе выполнения курсовой работы была реализована модель Барабаши"--~Альберт. Все расчёты производились на компьютере с процессором Intel core i5-8265U и 16 ГБ оперативной памяти. Модель реализована на Python 3.9.1 с помощью библиотек networkx\cite{nx}, multiprocessing, random и numpy.random.

Реализованная модель представляет собой модель растущего случайного графа предпочтительного связывания. В реализованой модификации на каждом шагу добавляется фиксированное количество $m$ рёбер, при этом вероятность появления ребра межу новой гранью и одной из старых пямо пропорциональна колличеству уже существующих соседей старой вершины. В эксперементах в качестве параметра $m$ подставляется число $5$, каждый вариант графа строится на 10000 вершин. Так как получаемые графы случайны, то в ходе эксперемента граф сроится шесдесят раз, и строится гистограмма по диапазонам индекса дружбы.
\subsection{Реализация стандартной модели Барабаши"--~Альберт}
Реализация стандартной модели Барабаши "--~ Альберт состоит в следующем. Сначала создаётся полный граф из $ m$ вершин с помощью команды\linebreak\mintinline{py}{nx.complete_graph(m)}. Затем в графе создаются $n-m$ вершин, но рёбра ещё не проводятся. Далее создаются и инициализируются вспомогательные массивы \mintinline{py}{nodes}, \mintinline{py}{used} и \mintinline{py}{degrees}, хранящие список присоединённых к графу вершин, информацию о том использованы они или нет и степени вершин, соответственно. 
Затем  в цикле добавляются ребра, как представлено в следующем коде.
\begin{minted}{python}
		for i in range(m, n):
        if not o :
            conections = []
            j = 0
            while j < m:
                choice = random.choices(nodes, weights = degrees, k = 1)
                choosen = choice[0]
                if not used[choosen]:
                    G.add_edge(i, choosen)
                    j += 1
                    conections.append(choosen)
                    used[choosen] = True
\end{minted}
Здесь описан цикл по неприсоединённым вершинам (см. стр.~1). Для каждой вершины, с помощью функции \mintinline{py}{random.choices()}, выбираются $ m $ различных вершин с которыми будет соединена новая вершина (см. стр.~6). Для того чтобы не было кратных ребер создаётся массив \mintinline{py}{connections}, хранящий все выбранные вершины (см. стр.~3, 11).


Следующим шагом с помощью массива \mintinline{py}{connections} исправляются массивы \mintinline{py}{used} и \mintinline{py}{degrees}. И новая вершина добавляется в массив\mintinline{py}{nodes}.
\begin{minted}{python}
for j in range(m):
	used[conections[j]] = False
	degrees[conections[j] - 1] += 1
	...
nodeCount += 1
	nodes.append(nodeCount)
	degrees.append(m)
\end{minted}
Случай добавления первой вершины рассматривается отдельно: если флаг \mintinline{py}{o} поднят, добавляется грань между нулевым и первым узлами. 
\begin{minted}{python}
  			else:
            G.add_edge(0, 1)
            o = False
        nodeCount += 1
        nodes.append(nodeCount)
        degrees.append(m)
    return G
\end{minted}
Далее по такому же алгоритму присоединяются другие вершины. Таким образом, получается алгоритм построения модели сучайного графа:
\begin{minted}{python}
		def my_bag(n, m):
      G = nx.complete_graph(m)
      for i in range(m, n):
          G.add_node(i)
      nodeCount = m
      o = True
      nodes = []
      degrees = []
      used = []
      for j in range(n):
          used.append(False)
      for i in range(m):
          nodes.append(i)
          degrees.append(m)
      for i in range(m, n):
          if not o :
              conections = []
              j = 0
              while j < m:
                  choice = random.choices(nodes, weights = degrees, k = 1)
                  choosen = choice[0]
                  if not used[choosen]:
                      G.add_edge(i, choosen)
                      j += 1
                      conections.append(choosen)
                      used[choosen] = True
              for j in range(m):
                  used[conections[j]] = False
                  degrees[conections[j] - 1] += 1
          else:
              G.add_edge(0, 1)
              o = False
          nodeCount += 1
          nodes.append(nodeCount)
          degrees.append(m)
      return G
\end{minted}
\subsection{Реализация метрик для выявления парадокса дружбы}
Для проведения эксперементов были реализованы функции \mintinline{py}{s, alpha, beta} вычисляющие сумму степеней соседей
\[
s_i(t) = \sum_{j: (v_i, v_j ) \in E(t)} deg_j(t),
\]
среднюю степень соседей 
\[
\alpha_i(t) = \dfrac{s_i(t)}{deg_i(t)}
\]
и индекс дружбы
\[
\beta_i(t) = \dfrac{\alpha_i(t)}{deg_i(t)} ,
\]
 соответственно, для массива поданых вершин. 
\begin{minted}{python}
def d (G, i):
    # print(i)
    return dict(G.degree)[i]
def s (G, i):
    ans = 0
    for j in G.neighbors(i):
        ans += dict(G.degree)[j]
    return ans
def alfa (G, i):
    return s(G, i) / d(G, i)
def beta (G, i):
    return alfa(G, i) / d(G, i)
\end{minted}
\subsection{Паралелизация построения модели Барабаши"--~Альберт}
Для ускорения работы программы была реализована многопоточная версия алгоритма с помощью библиотек multiprocessing и  numpy: функция \mintinline{py}{run} создаёт потоки, распределяет задания и собирает результаты, а функция \mintinline{py}{run_thread} проводит эксперементы на каждом ядре отдельно и возвращает их результат.

Сначала в функции \mintinline{py}{run} создаётся объект класса \mintinline{py}{multiprocessing.Manager}, который будет управлять в дальнейшем созданными потоками, ссылка на словарь с результатами вычислений - \mintinline{py}{manager.dict()} хранится в переменной \mintinline{py}{res}. Затем в цикле для каждого ядра создаётся свой \mintinline{py}{multyprocessing.Process} который будет выполнять соответсвующий поток, все процессы добавляются в список выполняющихся потоков и запускаются, с помощью метода \mintinline{py}{p.start}. Далее мы дожидаемся выполнения всех потоков, собираем все результаты в список \mintinline{py}{ans} и возвращаем его ка результат функции.

Первым шагом в \mintinline{py}{run} инициализируется пустой список \mintinline{py}{ans}. Потом поочерёдно строится заданное колличество случайных графов, для каждого из них вычисляется заданная метрика и результат записывается в список  \mintinline{py}{ans}.
\begin{minted}{python}
def run_thread(n, m, N, i, res, args, f):
    ans = []
    for j in range(N):
        G = my_bag(n, m)
        ans.append(np.apply_along_axis(lambda x: f(G, x[0]), 0,[args]).tolist())
    res[i] = ans
def run(n, m, N, treads, args, f):
    assert N % treads == 0
    global run_thread
    procs = []
    manager = multiprocessing.Manager()
    res = manager.dict()
    for i in range(treads):
        p = multiprocessing.Process(target=run_thread, args=(n, m, math.ceil(N/treads), i, res, args, f))
        procs.append(p)
        p.start()
    for proc in procs:
        proc.join()
    ans = []
    for i in res.values():
        ans += i
    return ans
\end{minted}
\subsection{Вывод и представление данных для анализа}
Данная реализация содержит фрагмент кода, отвечающий за отображение данных о построенном графе для дальнейшего анализа. Для этого используются библиотеки matplotlib, matplotlib.pyplot\cite{ptl} и numpy. 

Функция \mintinline{py}{numpy.histogram} получая на вход массив состоящий из индексов дружбы для всех вершин полученных во всех экспериментах и 
преобразует его в массив содержащий двенадцать диапазонов и двенадцать счётчиков принадлежащих им индексов. Затем этот массив делится на колличество эксперементов, для нахождения усреднённых результатов, и по нему строится столбчатая диаграмма, с помощью функции \mintinline{py}{bar} из библиотеки pyplot.

\begin{minted}{python}
ans = np.histogram(run(k, l, 60, 6, np.array(range(k//1)) * 1, beta), bins = 12)
plt.bar(ans[1][:-1], ans[0] / 60)
plt.show()
\end{minted}
Полный код программы приведен в приложении~\ref{app:program}.
\section{Анализ}
Так как модель Барабаши"--~Альберт подходит для описания реальных систем, в том числе сети Интернет, то распределение индекса дружбы в этой модели должно соответствовать его распределению в реальных сетях. 

Примером могут служить графики распределения индекса дружбы в сети телефонных звонков и сети доставки Amazon, представленные на рис. \ref{fig:img1}\cite{NSB}, соответствует гистограмме построенной для алгоритма Барабаши"---Альберт (см.  рис. \ref{fig:img2}).

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{examples2.jpg}
    \caption{Распределения индекса дружбы в\\ социальных сетях Facebook и Github}\label{fig:img1}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.7]{res.png}
    \caption{Распределение индекса дружбы  в\\ модели Барабаши"---Альберт}\label{fig:img2}
\end{figure}

Эксперименты, проведенные в ходе выполнения курсовой работы показали, что модель случайного графа Барабаши"--~Альберт подходит для моделирования процессов, происходящих в социальных сетях и других сложных системах.

% Раздел "Заключение"
\conclusion
В ходе выполнения курсовой работы были изучены различные модели генерации случайных графов, и проведены исследования стандартной модели Барабаши"--~Альберт. Проведенные эксперименты показали, модель случайного графа Барабаши"--~Альберт подходит для моделирования процессов, происходящих в социальных сетях и других сложных системах. Также были изучены различные модули языка программирования Python такие как: networkx(для работы с графами), random и numpy.random(для работы со случайными величинами), multiprocessing(для выполнения паралельных вычислений), а также matplotlib, matplotlib.pyplot и pylab(для построения и отображения графиков).



% Список литературы
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением

\appendix
\section{Текст программы}\label{app:program}
В этом приложении приведён полный текст реализации модели Барабаши"--~Альберт.
\begin{minted}{python}
from multiprocessing.dummy import current_process
from statistics import mean

import matplotlib as mpl
import matplotlib.pyplot as plt
import networkx as nx
import math
import random
import pylab
import multiprocessing
import datetime

import matplotlib as mpl
import matplotlib.pyplot as plt
import networkx as nx
import math
import numpy as np
import random
import pylab
def my_bag_poisson(n, m):
    m0 = np.random.poisson(m)
    G = nx.complete_graph(m0)
    for i in range(m0, n):
        G.add_node(i)
    nodeCount = m0
    o = True
    nodes = []
    degrees = []
    used = []
    for j in range(n):
        used.append(False)
    for i in range(m0):
        nodes.append(i)
        degrees.append(m0)
    mi = np.random.poisson(m0, n)
    for i in range(m0, n):
        if not o :
            conections = []
            j = 0
            while j < min(mi[i], nodeCount):
                choice = random.choices(nodes, weights = degrees, k = 1)
                choosen = choice[0]
                if not used[choosen]:
                    G.add_edge(i, choosen)
                    j += 1
                    conections.append(choosen)
                    used[choosen] = True
            for j in range(min(mi[i], nodeCount)):
                used[conections[j]] = False
                degrees[conections[j] - 1] += 1
        else:
            G.add_edge(0, 1)
            o = False
        nodeCount += 1
        nodes.append(nodeCount)
        degrees.append(m)
    return G

def my_bag(n, m):
    # print(n + m)
    G = nx.complete_graph(m)
    for i in range(m, n):
        G.add_node(i)
    nodeCount = m
    o = False
    nodes = []
    degrees = []
    used = []
    for j in range(n):
        used.append(False)
    for i in range(m):
        nodes.append(i)
        degrees.append(m)
    for i in range(m, n):
        if not o :
            conections = []
            j = 0
            while j < m:
                choice = random.choices(nodes, weights = degrees, k = 1)
                choosen = choice[0]
                if not used[choosen]:
                    G.add_edge(i, choosen)
                    j += 1
                    conections.append(choosen)
                    used[choosen] = True
            for j in range(m):
                used[conections[j]] = False
                degrees[conections[j] - 1] += 1
        else:
            G.add_edge(0, 1)
            o = False
        nodeCount += 1
        nodes.append(nodeCount)
        degrees.append(m)
    return G

def run_thread(n, m, N, i, res, args, f):
    ans = []
    for j in range(N):
        G = my_bag(n, m)
        ans.append(np.apply_along_axis(lambda x: f(G, x[0]), 0,[args]).tolist())
    res[i] = ans
def run(n, m, N, treads, args, f):
    assert N % treads == 0
    global run_thread
    procs = []
    manager = multiprocessing.Manager()
    res = manager.dict()
    for i in range(treads):
        p = multiprocessing.Process(target=run_thread, args=(n, m, math.ceil(N/treads), i, res, args, f))
        procs.append(p)
        p.start()
    for proc in procs:
        proc.join()
    ans = []
    for i in res.values():
        ans += i
    return ans
def d (G, i):
    # print(i)
    return dict(G.degree)[i]
def s (G, i):
    ans = 0
    for j in G.neighbors(i):
        ans += dict(G.degree)[j]
    return ans
def alfa (G, i):
    return s(G, i) / d(G, i)
def beta (G, i):
    return alfa(G, i) / d(G, i)
if __name__ == "__main__":
    k = 10000
    l = 5
    
    ans = np.histogram(run(k, l, 60, 6, np.array(range(k//1)) * 1, beta), bins = 12)

    # ans = np.apply_along_axis(mean, 0, run(k, l, 12, 6, np.array(range(k//1)) * 1, beta))
    # h = 
    plt.bar(ans[1][:-1], ans[0] / 60)
    plt.show()
\end{minted}
\end{document}
